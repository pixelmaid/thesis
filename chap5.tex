%% This is an example first chapter.  You should put chapter/appendix that you
%% write into a separate file, and add a line \include{yourfilename} to
%% main.tex, where `yourfilename.tex' is the name of the chapter/appendix file.
%% You can process specific files by typing their names in at the 
%% \files=
%% prompt when you run the file main.tex through LaTeX.
\chapter{Design Tools}
\todo{introduction to design tools}

\section{Design Tool Evaluation Methodology}
The workshops were evaluated through pre and post surveys, interviews, and photographs of student projects.  The surveys were aimed at understanding participants’ previous experience in programming and design, their interest in and attitudes toward programming and design (before and after the workshops), and their engagement in and enjoyment of the workshops.
Pre-surveys were administered at the start of the workshops and focused on participants’ previous experience and attitudes. They also asked students to describe their opinions about how programing and craft could be combined, and how they felt programming could extend or limit creativity. Post-surveys were administered at the termination of the workshops and contained attitudinal questions that were matched to the pre-surveys. In addition, post surveys contained a range of written questions asking the participants to describe their opinion of the success of their projects and their experience using Codeable Objects, Soft Objects or DressCode respectively.  
In-person interviews were conducted with the participants in the fashion workshop. These interviews lasted an average of 15-30 minutes and were audio recorded and transcribed. During the interviews, the participants were asked to describe their experience in the workshop and talk about the process of conceptualizing, designing and producing their garments. They were asked to describe what they enjoyed, what was difficult for them, and what they felt they had learned through this process. 
Survey and verbal interview responses and project outcomes were then analyzed to determine if the essential qualities outlined in the requirements section (above) were achieved.  We also used this information to identify recurring and prominent themes in participants’ experiences.

\section{Codeable Objects}

\begin{center}
\includegraphics[width=6.5in]{images/finished_lamps.png}
\end{center}



Codeable Objects is computational design tool that allowed people to design a laser cut lamp. The choice of a lamp allowed for a relatively broad design space wherein aesthetics were a primary consideration, while still retaining the qualities of functionality and utility in the finished product.  Lamps possess an established function, but offer a great deal of flexibility and personal freedom in the aesthetics and form. In addition, there is an established history of creating DIY lamps via digital fabrication. The Instructables community tutorial website has an entire section devoted to DIY lamps, and many examples of patterns that use a laser cutter for fabrication. 
\begin{center}
\begin{figure}[h!]
\includegraphics[width=6.5in]{images/instructables_lamps.png}
\caption{a selection of laser cut lamps from Instructables}
\end{figure}
\end{center}
\subsection{Motivation}
One of the restrictions of many of these examples is that they require the person making the lamp to directly emulate the design provided by the creator of the tutorial. If the person wishes to deviate from the original design, they  need to use a CAD tool like Adobe Illustrator or Solid Works\cite{instructables_lamp_1}. As mentioned in Section \ref{sec:professional_computational_design_tools}, professional CAD tools like Solid Works are often difficult to access and use for casual practitioners. In addition, during my personal experience in using a non-parametric tool like illustrator to design, I often found I had to resort to fabricating numerous sample pieces of in order to ensure the joints and form would function correctly in the final piece. If I made a mistake, or decided I wanted to modify the design, I lost time and materials in the fabricating process, and had to endure the tedious process of adjusting correcting each individual part. 
\begin{center}
\begin{figure}[h!]
\includegraphics[width=6.5in]{images/solidworks_lamp.png}
\caption{Instructables lamp tutorial with SolidWorks design process}
\end{figure}
\end{center}
One of the most frequent applications of a laser cutter is to create 3D forms by assembling 2D press fit pieces in a frame-like structure. I found that when creating 3D forms that were curved, it was extremely challenging in traditional 2D CAD software to correctly size and design parts which would fit the faces of the form. This was particularly relevant to lamp design, wherein it was necessary to create shades to diffuse the light. The shades also provided an excellent space for incorporating styles and patterns into the lamp. The combined tasks of simplified design and customization, parametric manipulation, and the calculation and conversion of a 3D form to 2D parts indicated that computational design would be a good match for the task of designing and fabricating a laser cut lamp. 
	
\subsection{Tool Description and workflow}
The objective of the first version of Codeable Objects was simple: to create a tool that allowed to design a custom lamp by describing the form and the pattern of the shades, which they could then fabricate and assemble. The lamp itself was comprised of 4 basic parts, a wooden press fit frame, a set of vellum pieces that fit over the frame to act as a shade,a set of cardstock pieces with a pattern that fit over the shades, and a commercial made light fixture that fit into the frame (see figure: \ref{fig:lamp_parts}.)
\begin{center}
\begin{figure}[h!]
\includegraphics[width=6.5in]{images/parts.png}
\caption{the individual parts of a lamp}
\label{fig:lamp_parts}
\end{figure}
\end{center}
Codeable Objects was developed as a programing library for Processing and contained a set of pre-defined programing methods that allow the user to describe the lamp, and define the tool paths for all three materials. The first version of the library was somewhat rough. All design took place via textual programing, and keyboard commands. Within the Processing IDE one imports and initialize the controller class of the library, and uses it to call four main functions that determine the height, top width, middle width and bottom width of the lamp. These 4 parameters are used to determine the form of the lamp, by generating the equation of a parabola with 3 intersection points. By rotating this parabola round the y-axis, it was possible to generate a closed 3-dimensional ellipsoid form.  The library also provided access to an additional set of methods that control over a number of other parameters in describing the form of the lamp, including the number of sides, the resolution of the curve and the position of the internal structural supports. To facilitate the construction process, notches are automatically generated in all of the individual parts to allow the form of the lamp to be press-fit together. The inclusion of this feature gives the user freedom to customize the shape of their lamp, without having to worry about the mechanics of construction. The library determines the correct position of the notches by calculating appropriate angle for each individual notch and determining the correct edge of intersection for each tool path based on this angle.  

 Codeable Objects also includes a second set of programing methods that allow users to describe the  decorative components of the lamp by specifying coordinates in polar or Cartesian space. Upon compilation, the coordinates are used by the application to calculate a design using a Voronoi diagram. A Voronoi diagram is a geometric subdivision of space that generates a quadrants based on a given point set according to the equidistant boundaries between all the points \cite{deBerg}. When the diagram is calculated, each segment is checked for intersection or containment with the polygon. Segments with both endpoints within the polygon are preserved unchanged, while segments with only one endpoint inside the diagram are clipped at the appropriate edge of intersection, by checking their angle against the angle of the points of the edges of the boundary. Segments which have both points outside of the polygon are checked for intersection using the segment intersection algorithm and either clipped according to their intersection points or removed altogether if they lack an intersection (fig: \ref{fig:voronoi_clipped}).
 \begin{wrapfigure}{r}{0.5\textwidth}
  \vspace{-20pt}
 \begin{center}
\includegraphics[scale=0.5]{images/voronoi_clipped.png}
\end{center}
\caption{Algorithim for constraining the voronoi diagram within the shade}
\label{fig:voronoi_clipped}
  \vspace{-10pt}
\end{wrapfigure}
  
Once the code is compiled, a graphic preview is displayed. For the pilot version, users could use key-commands to toggle between a view of the form of the 3D form of lamp, the voronoi-diagram pattern, and a 2D preview of the press fit parts (fig:\ref{fig:codeable_objects_v1}.) A final key-command allowed for the resultant design files to be exported as three separate pdfs, containing the paths for the press-fit frame, the shades, and the pattern files. 

\begin{center}
\begin{figure}[h!]
\includegraphics[width=6.5in]{images/codeable_objects_v1.jpg}
\caption{The first version of Codeable Objects, with only text-based interaction}
\label{fig:codeable_objects_v1}
\end{figure}
\end{center}
		
\subsection{Evaluation}
Using this basic pilot library, the first evaluation of Codeable Objects was conducted with a group of nine graduate students, ranging in age from 24-34, who engaged in a six-hour workshop. Five participants were women.  According to self-reported pre-survey data, all but one of the participants were intermediate to experienced programmers. Five of the nine had previous experience with Processing. In contrast, participants indicated they had little or no prior experience in design.  What experience they had was primarily gained in high school art classes and college elective courses. 
During the workshop, each participants engaged in the design and fabrication of a lamp. Participants received programing instruction in the use of Codeable Objects and a basic explanation of the principles behind the geometry of the lamp. The pilot version of Codeable Objects was packaged with a set of example programs that contained the basic code for initializing the library and defining the parameters of the lamp, a long with a variety of point generation methods. Examples included algorithms to generate spirals, circles and sine and cosine wave distributions of points. Participants were also provided with access to materials, and received training in the use of the laser cutter. Participants were given approximately four hours to design the structure and ornamentation of their lamp, followed by instruction on and access to the laser cutter. After cutting, participants were provided instructions about how to assemble their lamps. 

\begin{center}
\begin{figure}[h!]
\includegraphics[width=6.5in]{images/finished_lamps2.png}
\caption{Several of the finished lamps from the first workshop}
\label{fig:finished_lamps}
\end{figure}
\end{center}

\subsection{ Workshop Results}
All but one of the participants in the Lamp workshop successfully completed their lamp. The one exception was a user who wished to incorporate a specialized light fixture into their piece, but unfortunately damaged her parts while waiting for the fixture to arrive. Participants with little or no prior programing experience primarily relied upon tweaking or remixing the example programs to design the form and pattern of their lamp, whereas those more experienced in programing experimented extensively with the library to produce a wide range of forms and patterns. One participant wrote a program that decomposed a black and white image into a point cloud and used that as the basis for her pattern. Another participant wrote a program that used a Gaussian distribution of points to achieve the gradual variation he desired in his final pattern. 

 The physical assembly process required additional time beyond the duration of the workshop for most participants. This can partially be attributed to the bottleneck on the laser cutter, however the design and crafting components of the project took longer than expected. Despite this, all the participants returned after the workshop to complete their projects, and each participants indicated on the survey that they were able to complete a finished product to their satisfaction. The physical objects produced were both attractive and functional; participants displayed their lamps in their offices and homes after completion. One participant returned several days later to build a second lamp so that he would have a matching set for his bedside tables (figure:\ref{fig:finished_lamps}.)		
		
		
\subsection{Discussion}

%The most evident success of the pilot version of Codeable objects was the high rate of project completion. This success rate was closely connected to the ability of the library to correctly constrain the design parameters of the lamp. Although participants at times had to re-fabricate parts due to incorrect settings on the laser cutter or variations in the physical materials, at no point did a participant have to re-fabricate their piece due to errors in the design itself. Once fabricated, all participants pieces fit together correctly. This success came at the cost however, of significant design limitations. Participants who wished to modify the form to have more than one curve, or create patterns that went beyond the restrictions of the Voronoi diagram had to resort to post-processing their design files with a different CAD tool. In general, the %

Because of their prior expertise, the experiences of the majority of the participants in the first study are not indicative of the feasibility of Codeable Objects for novice programmers. Their experiences provide valuable contrast to the experience of the novice coders in the successive workshops however, and provide important information about the usability and workflow of the software. Despite their experience in programing however, the experienced programmers in the lamp workshop exhibited limited knowledge of computational design prior to the start of the workshop. When asked in the pre-workshop surveys how they thought programing, design and craft could be combined, the general response was either uncertain, or as method to create dynamic interactivity, rather than a tool for the design of form and pattern:

\textit{``You can combine software and hardware and make craft more dynamic (e.g. sensors). [Lamp Participant pre 1]}

\textit{``[Programing] gives [you] the ability to make something dynamic. [Lamp Participant pre 3]}

Following the workshop, the participants were generally pleased with the creative affordances of the tool, and described how the software enabled them to expand their programing abilities to the realm of art and craft with greater success: 

\textit{``I think programming makes designing more accessible because you don't have to be able to draw or paint. 
[Lamp participant post 4] }

\textit{``I love the idea of being able to combine my interest in programming for creative expressions. 
[Lamp participant post 6]}

There was also an awareness among several participants about the practical benefits of combining computational design and digital fabrication:

\textit{``I understand now how programming can be used for quick prototyping and mockups that can be used to inform final design decisions. This is easy [and] helpful when using physical materials where mistakes can be costly. 
[Lamp participant post 2]}

\textit{``Using programming in the design process adds some exciting and unique capabilities over traditional design and crafting, including mixing in different algorithm and ideas from other existing software, and rapid prototyping of complex designs."[Lamp participant post 6]}

From these responses, it is apparent that even among experienced programmers, algorithmic craft has the potential to expand people's understanding of the applications of programming and motivate them to apply computation to other forms of production and expression. There were also elements of the process and tool that were problematic for the participants. It became immediately clear during the workshop that textual programing was not the optimal method of modifying the form of the lamp. Many of the participants became frustrated about having to set the parameters and then wait for the compilation process to complete before they could view the resulting form. This issue was addressed partly in subsequent versions of the tool by replacing the textual parameters with a set of sliders in the compiled application, which would adjust the form in real time, across each of the views (figure: \ref{fig:slider_interface}.)
\begin{center}
\begin{figure}[h!]
\includegraphics[width=6.5in]{images/slider_interface.png}
\caption{Revised graphic view with sliders}
\label{fig:slider_interface}
\end{figure}
\end{center}

The textual programing method proved to be useful in the context of the point specification for the pattern. The simple method of specifying points in a programing context, allowed for the wide degree of variation and approaches in the resulting designs. If the tool had relied on a more standard set of graphical user interface(UI) components, like sliders to control the point generation, it is doubtful that the same range and creativity could have been achieved. On the other hand, it was clear that the less experienced programmers had more difficulty deliberately designing the patterns of their lamps, and relied primarily on adjusting and remixing existing examples. 

Several participants also put forth detailed critiques of the programming process, which brought into focus concerns about the practice of computational design itself. One participant reacted against defining the generative qualities of the Voronoi diagram patterns as a design method:

 \textit{`"Changing the parameters didn't always generate the pattern you have in mind. It was more like generating a few semi-random patterns and you choose one that looks good. It is rather a trying-and-choosing rather than designing /making something you planned to have. I think "design" involves "intention" and "planning." Programming, crafting, and design should be combined in the way that entails prior planning and intentions as opposed to cutting together the semi-random choices, which could be good but I wouldn't call that design. [Lamp participant post 6]"}
 
This comment addresses the concern that the attributes of randomness and generativity do not automatically lead to optimal or good design decisions. Some deciding factor has to play a role in the process, but the designer’s role in the deciding process is often ambiguous. This criticism touches on a core debate about the role of conscious design and the restriction of intuitive creativity in computational practices overall, however it is particularly relevant to computational design. The emergence of comments like this are encouraging, because they reflect the engagement of the participants, not just with the task at hand, but in a critical evaluation of the  creative implications of this form of creation. This comment however also highlights a key restriction of Codeable Objects. While it is ambiguous to the extent at which adjusting the parameters and input values to a system constitutes design, the task of defining the algorithms which shape the system itself are decidedly a form of design. With Codeable Objects however, the user is unable to modify the core algorithms which define the range of forms and patterns that are possible, unless they alter the source code of the library itself. When evaluated as a tool for algorithmic craft, Codeable Objects could have done a better job of supporting some of the deeper components of computational design, in particular, the algorithmic abstraction of personal styles and aesthetics. The stylistic limitations contained in the tool most likely contributed to the high success rate in project completion, and the general attractiveness of the resulting projects, but the experience of the workshop, provided the motivation for future tools to have better balance of stylistic and computational openness and accessibility for new programmers. 

One other defining component of the Codeable Objects pilot workshop was the stark contrast between the nature of the challenges in the computational design and digital fabrication components and the crafting component. The difficulties people experienced while designing and fabricating their projects were often discrete, for example correcting for mathematical error in coordinate placement, or having the incorrect setting on the laser cutter. More complex problems sometimes arose in these contexts as well, such as confusing on the principles behind some of the more complex point generation algorithms, or the programming aspects in general, however they were seemingly aspects that could be addressed through verbal instruction and explanation. The challenges encountered in the crafting session were of a different quality, concerning the best techniques for assembling the parts so that the resulting product maintained an attractive appearance. Most participants were surprised at the amount of time required to complete the physical assembly, and were often frustrated when variations in the crafting process violated the precision and perfection of the digital design, and laser cut parts. Some of the frustrations in the physical construction process were addressed in subsequent workshops by creating a paper variation of the lamp that was faster and easier to assemble and required no gluing (figure: \ref{fig:paper_lamp}.) In addition, a feature was added to the software which to report the approximate material size required for a design, so that users could ensure their would fit on the bed of the laser cutter. 
\begin{center}
\begin{figure}[h!]
\includegraphics[width=6.5in]{images/paper_lamps.png}
\caption{The revised paper lamps}
\label{fig:paper_lamp}
\end{figure}
\end{center}
Although there is often an opportunity to improve a user's experience through improvements in the interface and artifact design, in craft, it is both impossible and undesirable to eliminate the properties of material variation, and the benefits of practice and experience. Many of the difficulties workshop participants experienced in the crafting process therefore do not reflect a failure in the tools, but rather challenges that are intrinsic to crafting, and best addressed through practice and familiarity with the materials. In this way, craft practice differs from computational practice. While approaches benefit from experience and practice, the approaches for solving problems differ significantly in programing and hand crafting. Programming often requires an analytical approach with an emphasis on consistency and regularity, whereas crafting requires a more intuitive process of responding and adjusting one's technique while in direct contact with the materials. An interesting question is then, how then, can algorithmic tools be presented in a manner that accustom users to operating in both discreet and intuitive modes of problem solving, and furthermore how can these two modes of working inform both craft and computational approaches simultaneously?

	\section{Soft Objects}
	
	\begin{center}
\includegraphics[width=6.5in]{images/fashion_show.png}
\end{center}
	
After an evaluation of the successes and limitations of the Codeable Objects library I made an effort to expand the library in a way that would allow for a broader range of computational design approaches and end products. In particular, I was interested in exploring the domain of algorithmically crafted garments and fashion accessories. To explore computational fashion design in the context of algorithm craft, I expanded the Codeable Objects tool into a more general programing library named SoftObjects and evaluated it over a 10 day workshop with young people.


\subsection{Motivation}
Fashion is an exiting domain to connect to computation, because it appeals to groups of people who are often under-represented in computer science, particularly women and girls. In addition, because garments and accessories are wearable, computational fashion design requires the programmer to consider questions of comfort, sizing and personal taste and and style; a set of concerns not often associated with most computer programs. With the growth public awareness of digital fabrication, there is particular enthusiasm for the wearable applications of emerging digital fabrication technology. Much of this excitement is directed towards 3D printed wearables and textiles. In July 2010, Iris Van Herpen released her Crystallization collection, which featured her first computationally designed, 3D printed piece, marking the first time a 3d printed garment had appeared on the runway \cite{herpen}. Herpen and many other fashion designers have continued using 3d printing as a medium for fashion since then. As a result, often in popular culture, computationally designed, digitally fabricated fashion is often synonymous with 3D printing. The 3D printed garments and accessories produced by professional designers like Van Herpen serve as wonderful inspiration for the future of digital fabrication, as they produce garments that would be impossible to fabricate through any other means. For the average individual however, computationally designed and digitally fabricated garments of this nature present significant limitations. Given current technology and material limitations, the majority of 3D printed garments are generally practical for every-day wear and require advanced fabrication techniques that are unavailable to the average designer. Garments like the N.12 bikini, designed by Continuum \cite{n12} are designed to be more practical, and available to consumers, however they still come at a steep price point (\$300 for the bikini top). Most importantly however, the construction of 3D printed garments of this nature, both in terms of materials and techniques, appear to have little in common with methods of traditional garment production, such as sewing, knitting and embroidery, and therefore offers few entry points to individuals with traditional skills to move into this space.

\begin{center}
\begin{figure}[h!]
\includegraphics[width=6.5in]{images/3d_prinited_high_fashion.png}
\caption{ 3D printed fashion (from left to right: Crystallization 3d Top by Iris Van Herpen, Drape Dress by Janne Kyttanen, N12 Bikini by Continuum Fashion, Strvct shoe by Continuum Fashion}
\label{fig:high_fashion}
\end{figure}
\end{center}

Although perhaps less publicized than 3D printed fashion, other other designers are merging fashion with computation and digital fabrication in more accessible forms. Diana Eng's Laser Lace tee collection contains laser-cut machine-washable t-shirts with floral-inspired iconography, and her Fibonacci scarf is created through traditional knitting techniques, meshed with a Fibonacci knit pattern. Eunsuk Hur's modular fashion pieces are inspired by tessellations and fractal geometry, but apply these structures for a practical end as well. By creating garments through laser-cut interlocking pieces, Hur's aim was to produce items that were robust and durable, also gave the user the opportunity to use their inner creativity to come up with new and interesting items, by rearranging the individual components (figure:\ref{accessible_fashion}.)

Examples such as these demonstrate a space in computational fashion design that is open to a broader range of participation and compatible a larger set of interests, and skillsets. In general, less novel fabrication machines, like laser cutters and vinyl cutters are dominant in this type of work, because they afford a wider range of materials and can produce garments at a much lower cost than 3D printers. This range of materials also translates to a wider set of possibilities for aesthetics and styles than most forms of 3D printing. It should be noted that accessible forms of 3D printing can produce compelling wearable objects, however they are generally on the scale of jewelry and small accessories. As a whole, garments designed and produced in this fashion fit more so with the parameters algorithmic craft, than the 3D printed high-fashion examples provided in the preceding paragraph. With this distinction in mind, I developed the Soft Objects programming library, and designed and conducted a workshop to explore the creative potential of computation and digital fabrication in the context of accessible and immediate fashion design.

\begin{center}
\begin{figure}[h!]
\includegraphics[width=6.5in]{images/accessible_fashion.png}
\caption{"Ready to wear" computational fashion (from left to right: Fibonacci Scarf by Diana Eng, Biomimicry laser-cut bracelet by Stefanie Nieuwenhuyse, Laser Lace All-Over Tee by Diana Eng,  Interstice bracelet by Nervous Systems, Modular Fashion by Eunsuk Hur}
\label{fig:accessible_fashion}
\end{figure}
\end{center}
		

\subsection{Tool description}
The Soft Objects library contains a set of methods that allows users to draw shapes and patterns and then export those shapes and patterns in a vector-file format that is compatible with x-y axis digital-fabrication machines. Similar to CodeableObjects, to use the library, a user imports it into the Processing environment and then writes and compiles code using the Processing editor. Soft Objects allows users to define and manipulate basic geometric primitives such as Points, Lines, Curves and Polygons. These primitives can then be collected within Pattern and Shape objects—structures designed to capture surface decoration and 2D structure, respectively—to form increasingly complex designs. 

Soft Objects is formulated on an Object Oriented Programming (OOP) paradigm, which lets users create and manipulate collections of geometric primitives—Patterns and Shapes. This structure differs from Processing’s drawing API, which uses a functional programing approach. The structure of Soft Objects enables users to simultaneously apply transformations to all of the elements in a collection that make up a complex pattern or shape. It is also possible to import scalar vector graphics files (SVGs) to incorporate pre-drawn designs as elements within a pattern or as a container for existing patterns.

\begin{center}
\begin{figure}[h!]
\fbox{\includegraphics[width=6.5in]{images/primitive_syntax.png}}
\caption{Soft Objects primitives}
\label{fig:softobjects_primitives}
\end{figure}
\end{center}
		

Users are presented with a 2D preview of their designs when they compile their code. Soft Objects supports a variety of digital-fabrication machines by allowing users to save designs to vector portable document format (PDF) files. PDFs can be used by different production tools, including ink-jet printers, vinyl cutters, laser cutters, and computationally controlled embroidery machines. Output from Soft Objects can be fabricated on essentially any x-y axis tool. 3D structures can be created by assembling fabricated pieces. Figure \ref{fig:softobjects_workflow} demonstrates the workflow from code to a finished object. 
The Soft Objects library also contains a collection of pre-defined algorithmic patterns that can be initialized, including Voronoi diagrams, Koch curves, and L-Systems, and an extensive set of example programs that users can modify and combine to produce individual results.		

\begin{center}
\begin{figure}[h!]
\includegraphics[width=6.5in]{images/softobjects_workflow.jpg}
\caption{Soft Objects workflow}
\label{fig:softobjects_workflow}
\end{figure}
\end{center}
		
\subsection{Workshop}
The evaluation of Soft Objects was conducted during a 10-day workshop with a representative group of participants—eight young adults, aged 11-17, 75\% male and 25\% female. A significant majority (88\%) stated in pre-surveys that they had little or no prior experience in programming, and only one participant had prior experience in Processing. All of the participants indicated some level of prior experience in art, design, or craft. Most attributed their design or craft experience to art or drawing classes.

The workshop was conducted at the Nuvu Magnet Innovation Center for Young Minds. Participants were given 10 days to conceptualize and construct a garment using a combination of computational design, digital fabrication, and traditional sewing and crafting. The second study was more open than the first; participants could produce any type of garment they wished as long as components of it were computationally designed and digitally fabricated. During the workshop, participants were introduced to Soft Objects and the concept of computational fashion through a multi-step process that engaged participants in different levels of programming through the construction of different garments and accessories. First, participants were provided with a small set of example programs similar to the lamp workshop. This step allowed them to manipulate a core set of parameters to generate the pattern and form of a scarf, which they then cut on the laser cutter (figure: \ref{fig:scarves_bracelets}.) 

\begin{center}
\begin{figure}[h!]
\includegraphics[width=6.5in]{images/scarves_bracelets.png}
\caption{Completed garments (from left to right: octagon dress, flag pants, samurai dress, viral sweatshirt)}
\label{fig:scarves_bracelets}
\end{figure}
\end{center}


Second, participants were instructed in a number of primary programing concepts, including iteration, function definition, and the use of variables and primitive data-types. During this instruction, participants were guided through the process of independently using Soft Objects and generating their own programs from scratch. They used these programs to create a design for a wooden bracelet (Fig. 3), which was then laser cut and assembled. After these two initiation activities, these participants were asked to conceive their own garments and provided with the resources to design, prototype, and craft finished garments.


\subsection{Results}
Participants in the fashion workshop were successful in using programing and digital fabrication to design and produce finished garments. During the initiation activities, participants independently wrote and compiled programs of their own and produced physical products based on the design generated from that program. Furthermore, with assistance from the instructors, the participants were able to apply more sophisticated programing methods to produce a diverse set of final products (Fig 4). One pair of students developed an “armor dress” by writing a program that geometrically described a single “scale” shape, imported a dress pattern from Illustrator and filled it with rows of scales that corresponded with the dimensions of the dress. Another pair created a geometrically inspired dress with a patterning of different-sized octagons and squares that were laser cut from starched fabric. Another student created American-flag-inspired pants using a program that generated random orderings of red and blue stripes on a white background. One group that was less interested in the process of sewing clothing created a program that generated a recursive virus-like pattern and then screen-printed the pattern on pre-made sweatshirts and t-shirts. 

\begin{center}
\begin{figure}[h!]
\includegraphics[width=6.5in]{images/fashion_results.png}
\caption{Bracelets and scarves from preliminary activities}
\label{fig:fashion_results}
\end{figure}
\end{center}


On the post survey, when asked if they “were able to complete a finished project to their satisfaction,” 100\% of the fashion participants responded yes. The resultant garments were attractive and functional, indicated by the fact that participants from the fashion workshop kept and wore their creations. Direct comparison of the pre-and post-workshop surveys also demonstrated that on average, participants in the fashion workshop indicated their interest in crafting increased after the workshop, as did their enjoyment of the design process. Eighty-eight percent of the participants in the fashion workshop indicated that they felt more comfortable programing after the workshop than before.

\subsection{Discussion}
The Fashion workshop occurred over a longer time period than the Lamp workshop, and explored a wider range of crafting and computational techniques. As a result, I had an opportunity to spend greater amounts of time observing and talking with the  participants. leading to a more comprehensive perspective on the benefits and challenges in conducting algorithmic craft  workshops. In addition, because the participants were nascent programers, their experiences better reflect those of the target demographic of this research. Through this workshop we confirmed that algorithmic craft activities can actively support the expression of personal identity in a positive setting. It can also foster feelings of confidence in programming and support aesthetic and technological literacy. The workshop also promoted a deep understanding of computation as evidenced by critiques of the participants as well as demonstrating the importance of physical prototypes in the design process. Finally, the workshop promoted a sustained engagement in programing. The evidence of these outcomes is discussed in greater detail below

 
\subsubsection{Identification as a programmer}
Similar to the participants in the Lamp workshop, the Fashion participants began with vague ideas about the applications of computation. When asked in the pre-workshop surveys how they thought programing, art and craft could be combined, participants responded in writing in the following ways:

\textit{"To be honest, I am not sure too sure how it would all be combined because I don't know much about programming."} [Fashion Participant Y]

\textit{"With programing, we can make programs do things for us. "}[Fashion Participant J]
In addition, the participants had almost no prior knowledge of computational design. Those participants who had some form of prior programing experience associated it largely with interactivity and actuation:
\textit{"I would love to combine things like T-shirts and speakers or other different types of technologies. "}[Fashion Participant J]

Following the completion of their final projects, participants were much more descriptive about the applications of programing:

\textit{"I think [programing and fashion] are really interesting but I never thought they could ever be together in one concept, and it’s awesome that I know that now- that you can design aesthetically pleasing things from coding."}[Fashion participant K]
\textit{"I’ve never thought of programing as physical, I thought it was only in computers. But then when we made the scarves and stuff, I thought that was really fun."}[Fashion participant M]

In addition, they expressed a growing confidence in their ability as programmers. During the interviews, several separately stated that that while they did not feel completely comfortable programing independently, the experience made programming feel significantly more accessible:

\textit{"For someone who never had any programing explained to them before, when you look at [computational drawing examples] it feels really inaccessible, but now that I’ve been taught a little bit of [programing], I can kind of crack at the walls a little bit and understand how it works, and that makes it more accessible to me."}[Fashion participant S]
\textit{"Even though now I’m not really a Processing expert now, I’ve just experienced it and it’s not as scary to me, like the idea of coding, you just kind of have to learn some stuff and practice it more, but I think I definitely understand the concept of it. [Fashion participant K]"}

Finally, the programmers in the fashion workshop expressed feelings of pride and a sense of accomplishment in their new-found programing skills:

\textit{''I’m actually kind of proud. I know what’s going on. It feels different…I just thought [programming] was just about these huge programs that you have to piece together, and that you have to be really, really smart to do it, but I can do it."} [Fashion participant P]
\textit{"I think it was really cool that we used [programing] for fashion, cause I think a lot of people might think people who do fashion aren’t really smart or something, and then they think that people who design code are like brilliant coders and can do really awesome stuff with it."}[Fashion participant K]

 The confidence, sense of belonging, and personal agency demonstrated in these comments stand in contrast to popular views of programming as specialized and inaccessible. These sentiments were also present in later workshops I conducted with other nascent programmers (discussed in the section \ref{sec:DressCode}), indicating that introducing programing in the context of algorithmic crafting not only has the potential to change people’s understanding of the relevance and applications of programing, but also promote a personal awareness of technological literacy and competence. 
 
\subsubsection{Application of computational affordances}
Aside from a general understanding of the potential applications of programing, participants were successfully able to leverage the advantages of computational design in their final projects. For example, the octagon dress used parametric design principles as the participants were able to change the size and orientation of the octagons in the dress by modifying several parameters at the start of their program to affect the entire pattern, rather than rotating and adjusting each shape independently. The samurai dress took advantage of the computational properties of precision and automation. With help from an instructor, the creators programmatically generated an individual vector file for each row of scales of the dress, expediting the production process (figure:\ref{fig:samurai_dress_progression}.)The samurai dress is particularly interesting because it shows a remarkably successful transition from the design expressed in original concept art by the participant, and the resultant garment. In later workshops it was often difficult to reconcile the sketched concepts with the qualities of computational design. Lastly, the viral shirt, demonstrated an application of generativity. The aesthetic of the viral pattern was produced through the use of a weighted random-number generator to determine the number and length of the branches in each recursion of the pattern. Although the implementation of the weighted number generator was facilitated through the help of the instructor, the participants came up with the idea of using it on their own.
\begin{center}
\begin{figure}[h!]
\includegraphics[width=6.5in]{images/samurai_dress_progression.png}
\caption{Progression of samurai dress (from left to right: concept sketch, computationally generated pattern,laser-cut components of final garment)}
\label{fig:samurai_dress_progression}
\end{figure}
\end{center}

Aside from conceiving of and applying computational-design approaches, participants demonstrated an understanding of the rationale behind the methods they were using. One of the participants in the armor dress project compared the process of programing the design of the dress to that of manually drawing it: 
\textit{''With drawing you can achieve everything programing can, but I would prefer to program it. [Programing] can be pretty convenient…the computer is helping me. Like if you want to make pizza, the computer is like a pre-made crust."}[Fashion participant E]

Participants also demonstrated an understanding of specific programing functionality. One participant described the point at which she understood the application of parameterization:

\textit{''One moment that stuck out was when you helped me make a code with original geometry that could be changed so that when you changed one thing it changed everything and that was cool because I felt like I actually made something that could be changed and then applied."}[Fashion participant K]

The ability to understand and describe how computational support one's creative objectives is essential in motivating an individual to spend time learning and implementing these methods. Once the aesthetic possibilities of the recursive viral pattern were apparent to the designers, they became engaged in better understanding the underlying algorithm, so that they could produce a pattern to their exact specifications. Conversely the participants were far less engaged during several of the introductory lessons when we introduced several elementary computational principles, such as defining data types, where it was unclear what the immediate design application was. Algorithmic craft presents the opportunity for participants to tackle complex computational problems with sophisticated approaches, however the problems themselves must be clearly grounded within the design objectives of the individual. One of the challenges in engaging new programmers in Algorithmic craft therefore, is in selecting programing approaches that allow for compelling aesthetic and design possibilities, but are also approachable for first-time coders. 

\subsubsection{Aesthetics and Identity Expressed through Code}
The fashion workshop provided the opportunity for participants to use computational aesthetics as a way to express their visual identity. Fashion can serve as a means of self-expression and for conveying one’s identity. Discussions of fashion conducted with the participants of the second workshop indicated that participants were aware of the connection between fashion and identity and were eager for opportunities to create clothes that expressed their style. As a result, the majority of the garments created in the workshop contained an expression of the “fashion sense” of the participants who created them. For example, the participant who created the flag pants was very explicit that the pants have some form of an American flag motif, but not resemble the traditional, and as he put it “tacky” flag pants that he commonly saw. He wanted his flag pants to be as he put it “something that he would actually want to wear.” His programing choices were made in direct consideration of his desire to create a pair of pants that he felt were “fashionable.” 

When asked about the experience of making and designing his pants he said:
\textit{''[The workshop] definitely changed my impression of making clothes, I thought it was pretty quick to make clothes, but it actually takes a long time, and it’s also really fun. I love the fabric I made."} [Fashion participant M]
His enthusiasm also was evident in the fact that after the pants were complete, he tried them on and wore them for the remainder of the workshop. This level of enthusiasm was common among participants; they all proudly modeled their creations, and many of them wore them home. This behavior suggests a relationship between the decisions made in a programing context, and the participant’s desires to express their visual identity. The participants were selective in the code they wrote to design their garments because they intended to wear the garments, and as a result, be represented by them. This powerful affective relationship between computation, design and self-expression provides a natural way to engage people in programing and design by supporting their personal interests. 

\subsubsection{Physical and Digital connections}

One of the challenges of Algorithmic Craft, alluded to in the Codeable Objects discussion, is that the practitioner must work between digital designs with physical materials and processes.  Physical prototypes often serve as a key point of transition between these spaces. In the fashion workshop, prototyping played an important role, and demonstrated how computational tools can support and sometimes hinder the prototyping process. The focus on fashion made it possible to supply the participants with large amounts of inexpensive test fabric. The laser cutter could cut fabric much more quickly than thick materials, which allowed participants to produce numerous prototypes of their projects before creating a final piece. Most groups produced two or three prototypes, with one participant creating six iterations of a single jacket. This rapid production process formed a direct connection between discoveries made in the physical prototyping space and decisions in the programing realm. In the case of the octagon dress, (figure:\ref{fig:fashion_results}), the participants first cut test rows of octagons to determine the appropriate scale, then adjusted their design by modifying their program. When they had cut out a second more complete version of the dress, they rotated one of the shoulder straps on the physical prototype and formed an idea for a one-sided shoulder strap. They implemented this design change in the digital version of the dress by making additional changes to the size and rotation of the shapes defined in the code. When asked about this process in the interview one of the participants said:
\textit{''I think it was really fun that we got to do a prototype first because then if you don’t like it, you don’t feel a lot of pressure because you can make it again really fast, and there’s no stress because if it doesn’t turn out well, then it’s not your final project.} [Fashion Participant K]
The combination of programming, rapid fabrication, and physical construction allowed for a design approach that transitioned from programing to fabrication to programming adjustments based on the fabricated elements, and then back to fabrication. This iterative approach resulted in a closely linked cycle of physical and digital engagement. 

Despite these positive results, many participants struggled with prototyping. These struggles were  evident in practical aspects, such as participants not saving their programs and digital design files  to come back to later(despite repeated reminders from the instructors to do so). Participants also frequently spent too much time on assembling their early prototypes and were frustrated when they realized they would have to make design changes and repeat some of the manual labor. Although we took pains in the workshop to introduce participants to the concept of prototyping, these instructions were not always absorbed. This may present an opportunity for future algorithmic crafting tools to contain specific features to encourage and support the physical prototyping process. One possibility that is often proposed in the HCI community is to include simulation tools that preview the constraints and behaviors of physical materials. The value of working with physical prototypes should also be supported however, by features that allow the designer to scale their files and fabricate first in miniature, and software that allows easy access and management of multiple versions of a design throughout the design process.

 \subsubsection{Enthusiasm in crafting and coding}
One of the most encouraging aspects of following the fashion workshop, was the participant's enthusiasm and desire to continue making. Participants talked extensively about what they would like to make in future with programming, consisting citing that they would like to continue making clothing, or other personal functional items like furniture and “things they could use around the house.” The experience of both sets of workshop participants also demonstrated the ability of these techniques to produce objects that were designed to complement personal items and living spaces. When asked what she would like to make if she continued to program, one participant responded: 

\textit{''Things like we’re making now, things that you would want to keep or use, things that look nice as opposed to like computer games, or “input-output” devices. I think those are fun, but it’s not as cool as things that you can hold in your hand. I actually hung up the scarf I made in my room, and now I can be like “I made this on Processing” and people will be like what? It’s cool! "}[Fashion participant K]

This enthusiasm, combined with the high potential for individual expression and sense of accomplishment encouraged us to continue exploring fashion and garment production as topic space for algorithmic craft. While the fashion workshop highlighted many positives in this sense, we also encountered several areas for improvement. 

\subsection{Limitations}
The most evident barriers in the Fashion workshop involved the syntactic challenges of programming. Many participants expressed a frustration with the syntax in both surveys and in-person interviews. Although the workshop participants were able to generate their own programs, they required more assistance from an instructor to write some of the commands. In addition, a feeling of needing to memorize programming syntax frequently translated to a sense of frustration. One participant stated in an interview:

\textit{''I couldn’t memorize things, so it also was frustrating for me to always have to get you to help me write the code."} [Fashion participant K]

Many people requested some form of written "cheat sheet" that listed the key methods and how to use them. They also pointed out that you often had to write a lot of code (such as import commands and setup and draw functions), even for simple tasks. Writing code for the first time is always challenging, however, the high levels of frustration registered by the participants often focused on aspects of programming that seemed extraneous to design. Because we wrote Soft Objects as a Processing library, it required that the syntax correspond to Java, which is a difficult language for beginners. Because Java is a general application language, it has many syntactic requirements that are unnecessary for computational design applications. Based on this difficulty I concluded that future algorithmic crafting tools should explore domain-specific languages that directly applied to design and fabrication, and were better suited for first time programmers. 
 
Along with difficulties with the programing syntax, participants struggled with some of the post-processing techniques. In order to be suitable for digital fabrication, many of the participant's computationally generated designs required some processing in Adobe illustrator. Usually this required using illustrator's shape boolean functionality to merge shapes or expand outlines so that the vector paths would correspond to the desired cut pattern on the laser cutter (figure:\ref{fig:illustrator_example}.) Although the methods to perform these operations were simple, they needed to be repeated every time the design was modified programatically. This was not only inefficient, but sometimes prevented people from determining if their designs were feasible for fabrication when they were in the programing environment. This difficulty encouraged me to focus on ways of removing the need for illustrator from the process altogether so that all design modifications could be initialized and updated programatically.
\begin{center}
\begin{figure}[h!]
\includegraphics[width=6.5in]{images/illustrator_example.png}
\caption{Illustrator shape booleans - the laser cutter would cut along the blue line (from left to right: vector path, expanded vector path, group of individual vector polygons, merged group of vector polygons)}
\label{fig:illustrator_example}
\end{figure}
\end{center}
Finally, as in the Lamp workshop, participants were frustrated by the delay between adjusting their code and seeing the results. Although, not an absolute solution to the challenges in learning programing syntax, a programing environment with more immediate feedback could assist with the issue of syntactic challenges by providing novice users with improved ways to visualize the effect their syntactic changes have on their design. The implementation of background compiling, the process by which code is automatically compiled and executed as changes are made, has been applied successfully in several tools for novice programmers, including Scratch and Alice, and more recently with Khan Academy \cite{khan}. Our reliance on the Processing for Soft Objects made the incorporation of real-time compilation infeasible, however it quickly became a goal for future tools.


\todo{\subsubsection{Critiques of computational design}}
\section{DressCode}\label{sec:DressCode}

\begin{center}
\includegraphics[width=6.5in]{images/dressCode_main.png}
\end{center}


The preliminary work of Codeable Objects and Soft Objects clearly demonstrated that algorithmic craft offers a compelling opportunity for personal, creative expression through programming. My goal following these projects was to address some the limitations present in these preliminarily projects by developing a stand-alone programing environment and design tool. The resulting software, DressCode is a tool developed expressly to support new programmers in open-ended casual computational design for digital fabrication. To evaluate Dress Code, I conducted two separate day long workshops, one with experienced programmers and designers, and one for young people who were new to programming. I also worked with FUSE, an out of school STEAM exploration program to develop a set of online activities using DressCode, which is currently in the preliminary stages of evaluation.	 

\subsection{Design principles}
Based on the success of the prior fashion workshop, and my continued interest in exploring applications that appeal to women and girls, I decided to focus on computational fashion design and the fabrication of wearable artifacts in the development of DressCode. After reflecting on the potential limitations of this focus however, I decided to develop DressCode as a more open-ended computational design tool that could support the creation of a variety of artifacts, rather than just fashion. To preserve the emphasis on fashion, the majority of the example projects and artifacts I created with DressCode for this thesis were fashion-oriented. The workshops I conducted, as well as the curriculum I helped develop also had an emphasis on fashion or wearable artifacts.

By building my own software, I sought to improve on the preliminary programming libraries in three key areas. First, DressCode contains its own programing language. The DressCode language has a simplified syntax and contains a limited set of textual programming methods, allowing people with little-to-no prior programming experience to working with the language quickly and effectively. Second, the DressCode environment is designed to equally prioritize textual programing and visual design and manipulation. To that end, the software has a two-panel development environment that displays a graphic two-dimensional (2-D) rendering of the user’s current design in the first panel, and their code in the second. As a user makes changes to their code, the effects on the design are rendered in the graphic panel. Finally, DressCode contains functionality that is specific to digital fabrication and algorithmic craft. The tool allows for a variety of methods to translate one's design to a tool-paths for fabrication machines. In addition, the API contains programing methods that support the creation of forms and patterns that are suitable for fabrication, with minimal effort on the part of the user.  The goal of designing a software 2-panel programing and design environment, with a specialized programing language and immediate support for digital fabrication was to assist non-programmers in independently making design decisions with programing. In short, I wanted to make it as easy as possible for people to decide on their own desired style or aesthetic, and then realize it by writing their own code. The following section describes the features of the DressCode software in greater detail.

\subsection{Tool description}
I've divided the description of DressCode into three sections: the programing syntax and drawing API, the interface design, and the process of going from DressCode to a fabrication machine.
\subsubsection{Programing Language}
The DressCode programing language is interpreted with semantic functionality that is simulated through a Java-based library.  We relied on the ANTLR framework to generate the necessary lexing and parsing methods for the language, and developed the semantic functionality using java and the java openGL (JOGL). When a program is run in DressCode, the raw script is first tokenized and then parsed to generate an abstract syntax tree (AST). During this phase, all user-generated function definitions are stored in memory. If any parsing errors are encountered, they are output to the console as "compiler errors". Assuming the parse is successful, DressCode then walks the resultant AST and attempts to execute the semantic functionality of the program (figure:\ref{fig:interpreter_structure}.) After being excecuted, the resultant design is rendered on the display panel. Any runtime errors are displayed in the output console. For most programs, this process is instantaneous, however some programs with complex operations require several seconds to be excecuted. 
  \begin{center}
\begin{figure}[h!]
\includegraphics[width=6.5in]{images/interpreter_structure_horz.png}
\caption{Interpreter structure}
\label{fig:interpreter_structure}
\end{figure}
\end{center}
The language is imperative in nature, with statements being executed in the order in which they are read. The exception to this is user defined functions, which may be defined at any point in the program, and called before they are defined. Each statement in DressCode must be terminated by a semicolon. I spent some time experimenting with terminating statements with newlines, similar to whitespace sensitive languages like Python, as I thought this might be more conducive to novice use. Unfortunately, the implementation of selective whitespace recognition is a challenging task to define in a grammar, so while we were able to develop a version of DressCode that recognized statements terminated by a line break, it would have taken significant time to develop this functionality to a level of robustness appropriate for user testing. For the short term, we have opted for a syntax requiring semicolons, however we plan to continue to explore newline statement termination in the future. 

DressCode supports number, string, boolean, and drawable datatypes (figure \ref{fig:basic_datatypes}.) The first four of these types are relatively standard in comparison to conventional programing languages. Numbers include integers and floating point values. Strings include any sequence of characters enclosed in double quotations. Booleans have two possible values: true, and false. Drawables are a special type, discussed in detail in the API description below. DressCode also contains a list data structure, which can store multiple kinds of datatypes.
\begin{center}
%\begin{figure}
\begin{lstlisting}
myString = "hello";  //string
myNum = 10.4;  //number
numbermyBool = true;  //boolean
myList = [10,11,false,"world"];  //list with multiple data types
println(myList[3]); //prints world
\end{lstlisting}
%\caption{basic datatypes}
%\label{fig:basic_datatypes}
%\end{figure}
\end{center}

Variable identifiers in DressCode must begin with a letter which followed by 0 or more letters or digits. Variables can be initialized through assignment, or declared and assigned later in the program. All assignment in DressCode is dynamically typed, and variables can be assigned to datatypes that differ from their original assignment at any point. %(figure \ref{fig:variable_assignment}.)

\begin{center}
%\begin{figure}
\begin{lstlisting}
s1 = "hello";
s2 = "world";
s3; //variable without initial assignment

s3 = s1+" "+s2; 
println(s3); //prints hello world

n1 = 2;
n2 = 2.5;
println(n1+n2*10); // returns 27.0
\end{lstlisting}
%\caption{variable assignment.}
%\label{fig:variable_assignment}
%\end{figure}
\end{center}

The  language also contains support for basic expressions, as well as block statements, including conditionals, loops and user-defined functions. For mathematical expressions, standard order of operations is maintained, unless parentheses are introduced. All block statements are signified by a keyword followed by a colon, and terminated with the end keyword which is not followed by a semicolon.Conditionals are defined with the if keyword, and may an optional else clause and  zero or more else if clauses. %(figure: \ref{fig:conditionals}.)

\begin{center}
%\begin{figure}
\begin{lstlisting}
//if statement 
if 5<10:
println("true"); //prints true
end

//if statement with else if and else clause
i=10;
if i<10:
println("less than 10");
else if i==10:
println("equals 10"); //prints equals 10
else:
println("greater than 10");
end
\end{lstlisting}
%\caption{conditional definitions}
%\label{fig:conditionals}
%\end{figure}
\end{center}

There are two possible loop statements: repeat statements and while statements. Repeat statements begin with the repeat keyword and are followed by a the initialization: a variable identifier with a numerical assignment, followed by a colon and the test, a number that determines the point at which the repeat statement will terminate. By default, all repeat statements have an update value of 1, however this can be modified by following the test value with "add" and a 3rd value specifying the update condition. While loops are initialized with the while keyword and followed by a test condition.%(figure: \ref{fig:loops}.) 

\begin{center}
%\begin{figure}
\begin{lstlisting}
//repeat statement
repeat i=0:10:
ellipse(0,i*10,10,10); //draws a vertical row of 10 ellipses
end

//repeat with modified update condition
repeat i=0:10 add 2:
println(i); //will print 0,2,4,6,8
end

//while statement
c=0;
while c < WIDTH:
ellipse(c,10,20);
c = c+20;
end
//draws a row of ellipses that span the width of the canvas
\end{lstlisting}
%\caption{loop definitions}
%\label{fig:loops}
%\end{figure}
\end{center}

Finally, custom functions are defined with the def keyword, followed by an identifier and a set of parentheses containing 0 or more arguments separated by commas. The function block is terminated with the end keyword like all other block statements. Just like general assignments, functions arguments are dynamically typed. Functions, loops and conditionals all have their own scope and will prioritize identifiers based on that, however if they cannot locate an identifier within their own scope, they will look for it in the level above.
\begin{center}
%\begin{figure}
\begin{lstlisting}
//basic function defintion
def foo(a,b,c):
println(a+b+c);
end

//function call
foo(1,2,3);  //prints 6

//function with return statement
def bar(a,b,c):
return(a*b*c);
end

result = bar(4,5,6)); 
println(result);//prints 120
\end{lstlisting}
%\caption{loop definitions}
%\label{fig:loops}
%\end{figure}
\end{center}


 The API is organized around the creation and transformation of 2D shape primitives. By duplicating and manipulating these primitives in a structured manner, it is possible to generate complex and interesting designs from simple forms. 

  \begin{center}
\begin{figure}[h!]
\includegraphics[width=6.5in]{images/api_table.png}
\caption{A selection of methods from the DressCode API}
\label{fig:api_table}
\end{figure}
\end{center}


  \begin{center}
\begin{figure}[h!]
\includegraphics[width=6.5in]{images/early_dress_code.png}
\caption{The first bare-bones version of DressCode}
\label{fig:early_dress_code}
\end{figure}
\end{center}

\subsubsection{Interface Design}
The interface of DressCode has two primary sections, a design panel and a coding panel. The divider between the two panels can be resized, allowing the the 
\begin{center}
\begin{figure}[h!]
\includegraphics[width=6.5in]{images/dress_code_interface.png}
\caption{The DressCode interface}
\label{fig:dress_code_interface}
\end{figure}
\end{center}
\subsubsection{Fabrication process}

\subsection{Workshops}
\subsection{Workshop results}
\subsection{Curriculum description}
\subsection{Preliminary curriculum results}
\subsection{Discussion}
\subsubsection{Starting notions of craft and computation}
\subsubsection{independent programming with a sense of ownership}
\subsubsection{Design Process and resultant aesthetics}
\subsubsection{Pride and Acomplishment in Algorithmic Craft}
\subsubsection{Design history and selection}
\subsubsection{Prototyping pt 2}
\subsubsection{Connection to other applications}

